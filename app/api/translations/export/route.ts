import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';

// GET - Esporta traduzioni in vari formati
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: 'Non autorizzato' }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const gameId = searchParams.get('gameId');
    const format = searchParams.get('format') || 'json';
    const status = searchParams.get('status');

    if (!gameId) {
      return NextResponse.json(
        { error: 'ID gioco mancante' },
        { status: 400 }
      );
    }

    // Costruisci la query
    const where: any = { gameId };
    if (status && status !== 'all') {
      where.status = status;
    }

    // Recupera le traduzioni
    const translations = await prisma.translation.findMany({
      where,
      include: {
        game: {
          select: {
            title: true,
            platform: true
          }
        }
      },
      orderBy: {
        filePath: 'asc'
      }
    });

    // Formatta i dati in base al formato richiesto
    switch (format) {
      case 'csv':
        return exportAsCSV(translations);
      
      case 'po':
        return exportAsPO(translations);
      
      case 'json':
      default:
        return exportAsJSON(translations);
    }
  } catch (error) {
    console.error('Errore nell\'esportazione delle traduzioni:', error);
    return NextResponse.json(
      { error: 'Errore nell\'esportazione delle traduzioni' },
      { status: 500 }
    );
  }
}

// Esporta come JSON
function exportAsJSON(translations: any[]) {
  const data = {
    exportDate: new Date().toISOString(),
    game: translations[0]?.game || {},
    translations: translations.map(t => ({
      filePath: t.filePath,
      originalText: t.originalText,
      translatedText: t.translatedText,
      targetLanguage: t.targetLanguage,
      sourceLanguage: t.sourceLanguage,
      status: t.status,
      context: t.context
    }))
  };

  return new NextResponse(JSON.stringify(data, null, 2), {
    headers: {
      'Content-Type': 'application/json',
      'Content-Disposition': `attachment; filename="translations_${data.game.title?.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json"`
    }
  });
}

// Esporta come CSV
function exportAsCSV(translations: any[]) {
  const headers = ['File Path', 'Original Text', 'Translated Text', 'Target Language', 'Status', 'Context'];
  const rows = translations.map(t => [
    t.filePath,
    `"${t.originalText.replace(/"/g, '""')}"`,
    `"${t.translatedText.replace(/"/g, '""')}"`,
    t.targetLanguage,
    t.status,
    t.context ? `"${t.context.replace(/"/g, '""')}"` : ''
  ]);

  const csv = [
    headers.join(','),
    ...rows.map(row => row.join(','))
  ].join('\n');

  return new NextResponse(csv, {
    headers: {
      'Content-Type': 'text/csv',
      'Content-Disposition': `attachment; filename="translations_${translations[0]?.game?.title?.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.csv"`
    }
  });
}

// Esporta come file PO (gettext)
function exportAsPO(translations: any[]) {
  const game = translations[0]?.game || {};
  const targetLang = translations[0]?.targetLanguage || 'it';
  
  const header = `# Translation file for ${game.title}
# Generated by GameStringer
# Date: ${new Date().toISOString()}
#
msgid ""
msgstr ""
"Content-Type: text/plain; charset=UTF-8\\n"
"Language: ${targetLang}\\n"
"MIME-Version: 1.0\\n"

`;

  const entries = translations.map(t => {
    let entry = '';
    
    if (t.context) {
      entry += `#. ${t.context}\n`;
    }
    
    entry += `#: ${t.filePath}\n`;
    entry += `msgid "${t.originalText.replace(/"/g, '\\"')}"\n`;
    entry += `msgstr "${t.translatedText.replace(/"/g, '\\"')}"\n`;
    
    return entry;
  }).join('\n');

  const po = header + entries;

  return new NextResponse(po, {
    headers: {
      'Content-Type': 'text/plain',
      'Content-Disposition': `attachment; filename="translations_${game.title?.replace(/\s+/g, '_')}_${targetLang}.po"`
    }
  });
}