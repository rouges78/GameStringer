/**
 * Patch Exporter - Esporta traduzioni come patch distribuibili
 * 
 * Supporta:
 * - ZIP patch (file tradotti pronti da estrarre)
 * - XUnity.AutoTranslator format (per giochi Unity)
 * - File .gstranslation (formato proprietario GameStringer)
 */

import JSZip from 'jszip';

export interface TranslatedFile {
  originalPath: string;      // Percorso originale nel gioco
  relativePath: string;      // Percorso relativo dalla root del gioco
  content: string;           // Contenuto tradotto
  originalContent?: string;  // Contenuto originale (per diff)
  format: string;            // Formato file (csv, json, txt, etc.)
  stringCount: number;       // Numero di stringhe tradotte
}

export interface PatchMetadata {
  gameName: string;
  gameId?: string;
  sourceLanguage: string;
  targetLanguage: string;
  translatedBy: string;
  createdAt: string;
  version: string;
  totalStrings: number;
  totalFiles: number;
  provider: string;
  notes?: string;
}

export interface ExportOptions {
  includeBackup: boolean;      // Include file originali nel backup
  includeReadme: boolean;      // Include README con istruzioni
  includeMetadata: boolean;    // Include metadata JSON
  xunityFormat: boolean;       // Esporta anche in formato XUnity
  compressionLevel: number;    // 0-9, livello compressione ZIP
}

const DEFAULT_EXPORT_OPTIONS: ExportOptions = {
  includeBackup: true,
  includeReadme: true,
  includeMetadata: true,
  xunityFormat: true,
  compressionLevel: 6
};

/**
 * Genera un pacchetto ZIP con i file tradotti
 */
export async function exportPatchZip(
  files: TranslatedFile[],
  metadata: PatchMetadata,
  options: Partial<ExportOptions> = {}
): Promise<Blob> {
  const opts = { ...DEFAULT_EXPORT_OPTIONS, ...options };
  const zip = new JSZip();
  
  // Cartella principale con nome gioco e lingua
  const folderName = `${sanitizeFilename(metadata.gameName)}_${metadata.targetLanguage.toUpperCase()}_patch`;
  const mainFolder = zip.folder(folderName)!;
  
  // Aggiungi file tradotti
  const translatedFolder = mainFolder.folder('translated')!;
  for (const file of files) {
    translatedFolder.file(file.relativePath, file.content);
  }
  
  // Backup dei file originali (opzionale)
  if (opts.includeBackup) {
    const backupFolder = mainFolder.folder('backup_original')!;
    for (const file of files) {
      if (file.originalContent) {
        backupFolder.file(file.relativePath, file.originalContent);
      }
    }
  }
  
  // XUnity.AutoTranslator format (opzionale)
  if (opts.xunityFormat) {
    const xunityFolder = mainFolder.folder('XUnity_AutoTranslator')!;
    const xunityContent = generateXUnityFormat(files, metadata);
    xunityFolder.file(`${metadata.targetLanguage}.txt`, xunityContent.mainFile);
    
    // Aggiungi anche file per categoria se ci sono molte stringhe
    if (xunityContent.categoryFiles) {
      for (const [category, content] of Object.entries(xunityContent.categoryFiles)) {
        xunityFolder.file(`${metadata.targetLanguage}_${category}.txt`, content);
      }
    }
  }
  
  // Metadata JSON
  if (opts.includeMetadata) {
    const metadataContent = JSON.stringify({
      ...metadata,
      files: files.map(f => ({
        path: f.relativePath,
        format: f.format,
        strings: f.stringCount
      })),
      exportedAt: new Date().toISOString(),
      exporterVersion: '1.0.0'
    }, null, 2);
    mainFolder.file('patch_info.json', metadataContent);
  }
  
  // README con istruzioni
  if (opts.includeReadme) {
    const readme = generateReadme(metadata, files, opts.xunityFormat);
    mainFolder.file('README.txt', readme);
    mainFolder.file('LEGGIMI.txt', generateReadmeItalian(metadata, files, opts.xunityFormat));
  }
  
  // Genera ZIP
  return await zip.generateAsync({
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: opts.compressionLevel }
  });
}

/**
 * Genera formato XUnity.AutoTranslator
 * Formato: testo_originale=testo_tradotto
 */
function generateXUnityFormat(
  files: TranslatedFile[],
  metadata: PatchMetadata
): { mainFile: string; categoryFiles?: Record<string, string> } {
  const lines: string[] = [
    `// ${metadata.gameName} - ${metadata.sourceLanguage.toUpperCase()} to ${metadata.targetLanguage.toUpperCase()} Translation`,
    `// Generated by GameStringer on ${metadata.createdAt}`,
    `// Translated by: ${metadata.translatedBy}`,
    `// Total strings: ${metadata.totalStrings}`,
    `// Provider: ${metadata.provider}`,
    '',
    '// ============================================',
    '// INSTALLATION:',
    '// 1. Install BepInEx (https://github.com/BepInEx/BepInEx)',
    '// 2. Install XUnity.AutoTranslator (https://github.com/bbepis/XUnity.AutoTranslator)',
    '// 3. Copy this file to: BepInEx/Translation/${metadata.targetLanguage}/Text/',
    '// ============================================',
    ''
  ];
  
  const categoryLines: Record<string, string[]> = {};
  
  for (const file of files) {
    // Estrai coppie originale/tradotto dal contenuto
    const pairs = extractTranslationPairs(file.content, file.format);
    
    if (pairs.length > 0) {
      lines.push(`// --- ${file.relativePath} (${pairs.length} strings) ---`);
      
      for (const pair of pairs) {
        // Formato XUnity: originale=tradotto
        const escapedOriginal = escapeXUnityString(pair.original);
        const escapedTranslated = escapeXUnityString(pair.translated);
        lines.push(`${escapedOriginal}=${escapedTranslated}`);
        
        // Categorizza per tipo di contenuto
        const category = detectCategory(pair.original);
        if (!categoryLines[category]) {
          categoryLines[category] = [];
        }
        categoryLines[category].push(`${escapedOriginal}=${escapedTranslated}`);
      }
      
      lines.push('');
    }
  }
  
  // Se ci sono molte stringhe, crea file separati per categoria
  let categoryFiles: Record<string, string> | undefined;
  if (metadata.totalStrings > 500) {
    categoryFiles = {};
    for (const [category, catLines] of Object.entries(categoryLines)) {
      if (catLines.length > 50) {
        categoryFiles[category] = [
          `// ${metadata.gameName} - ${category} strings`,
          `// ${catLines.length} entries`,
          '',
          ...catLines
        ].join('\n');
      }
    }
  }
  
  return {
    mainFile: lines.join('\n'),
    categoryFiles
  };
}

/**
 * Estrae coppie originale/tradotto dal contenuto del file
 */
function extractTranslationPairs(
  content: string,
  format: string
): Array<{ original: string; translated: string }> {
  const pairs: Array<{ original: string; translated: string }> = [];
  
  try {
    switch (format.toLowerCase()) {
      case 'csv':
        // Assume formato: ID,ORIGINAL,TRANSLATED o simile
        const csvLines = content.split('\n').filter(l => l.trim());
        for (let i = 1; i < csvLines.length; i++) { // Skip header
          const cols = parseCSVLine(csvLines[i]);
          if (cols.length >= 2) {
            // Cerca colonne che sembrano originale e tradotto
            const original = cols[1] || cols[0];
            const translated = cols[cols.length - 1] || cols[1];
            if (original && translated && original !== translated) {
              pairs.push({ original, translated });
            }
          }
        }
        break;
        
      case 'json':
        const json = JSON.parse(content);
        extractJsonPairs(json, pairs);
        break;
        
      case 'txt':
      case 'ini':
        // Formato key=value
        const txtLines = content.split('\n');
        for (const line of txtLines) {
          const match = line.match(/^([^=]+)=(.+)$/);
          if (match) {
            pairs.push({ original: match[1].trim(), translated: match[2].trim() });
          }
        }
        break;
    }
  } catch (e) {
    console.warn('Error extracting translation pairs:', e);
  }
  
  return pairs;
}

function extractJsonPairs(
  obj: any,
  pairs: Array<{ original: string; translated: string }>,
  prefix = ''
): void {
  if (typeof obj === 'string') {
    return;
  }
  
  if (Array.isArray(obj)) {
    obj.forEach((item, i) => extractJsonPairs(item, pairs, `${prefix}[${i}]`));
    return;
  }
  
  if (typeof obj === 'object' && obj !== null) {
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'string' && value.trim()) {
        // Usa la chiave come "originale" e il valore come "tradotto"
        pairs.push({ original: key, translated: value });
      } else {
        extractJsonPairs(value, pairs, `${prefix}.${key}`);
      }
    }
  }
}

function parseCSVLine(line: string): string[] {
  const result: string[] = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (char === ',' && !inQuotes) {
      result.push(current.trim());
      current = '';
    } else {
      current += char;
    }
  }
  
  result.push(current.trim());
  return result;
}

function escapeXUnityString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t')
    .replace(/=/g, '\\=');
}

function detectCategory(text: string): string {
  const lower = text.toLowerCase();
  
  if (lower.includes('menu') || lower.includes('button') || lower.includes('click')) {
    return 'ui';
  }
  if (lower.includes('item') || lower.includes('weapon') || lower.includes('armor')) {
    return 'items';
  }
  if (lower.includes('quest') || lower.includes('mission') || lower.includes('objective')) {
    return 'quests';
  }
  if (lower.includes('skill') || lower.includes('ability') || lower.includes('spell')) {
    return 'skills';
  }
  if (text.length > 100) {
    return 'dialogue';
  }
  
  return 'misc';
}

function sanitizeFilename(name: string): string {
  return name
    .replace(/[<>:"/\\|?*]/g, '_')
    .replace(/\s+/g, '_')
    .substring(0, 50);
}

function generateReadme(
  metadata: PatchMetadata,
  files: TranslatedFile[],
  hasXUnity: boolean
): string {
  return `
================================================================================
${metadata.gameName} - ${metadata.targetLanguage.toUpperCase()} Translation Patch
================================================================================

Created by: ${metadata.translatedBy}
Date: ${metadata.createdAt}
Version: ${metadata.version}
Source Language: ${metadata.sourceLanguage.toUpperCase()}
Target Language: ${metadata.targetLanguage.toUpperCase()}
Total Strings: ${metadata.totalStrings}
Total Files: ${metadata.totalFiles}
Translation Provider: ${metadata.provider}

================================================================================
INSTALLATION - METHOD 1 (Direct Replace)
================================================================================

1. Navigate to your game installation folder
2. BACKUP your original files first!
3. Copy all files from the "translated" folder to the game folder
4. Overwrite when prompted
5. Launch the game

To restore original files, copy from "backup_original" folder.

${hasXUnity ? `
================================================================================
INSTALLATION - METHOD 2 (XUnity.AutoTranslator - Recommended for Unity games)
================================================================================

This method does NOT modify original game files.

1. Download and install BepInEx:
   https://github.com/BepInEx/BepInEx/releases

2. Download and install XUnity.AutoTranslator:
   https://github.com/bbepis/XUnity.AutoTranslator/releases

3. Copy the .txt file(s) from "XUnity_AutoTranslator" folder to:
   [Game Folder]/BepInEx/Translation/${metadata.targetLanguage}/Text/

4. Launch the game - translations will be applied automatically!

Benefits of this method:
- Original files remain untouched
- Easy to update translations
- Can be toggled on/off
- Works with game updates
` : ''}

================================================================================
FILES INCLUDED
================================================================================

${files.map(f => `- ${f.relativePath} (${f.stringCount} strings)`).join('\n')}

================================================================================
NOTES
================================================================================

${metadata.notes || 'No additional notes.'}

This translation was created using GameStringer.
Report issues or contribute at: https://github.com/your-repo/gamestringer

================================================================================
`.trim();
}

function generateReadmeItalian(
  metadata: PatchMetadata,
  files: TranslatedFile[],
  hasXUnity: boolean
): string {
  return `
================================================================================
${metadata.gameName} - Patch Traduzione ${metadata.targetLanguage.toUpperCase()}
================================================================================

Creato da: ${metadata.translatedBy}
Data: ${metadata.createdAt}
Versione: ${metadata.version}
Lingua Originale: ${metadata.sourceLanguage.toUpperCase()}
Lingua Tradotta: ${metadata.targetLanguage.toUpperCase()}
Stringhe Totali: ${metadata.totalStrings}
File Totali: ${metadata.totalFiles}
Provider Traduzione: ${metadata.provider}

================================================================================
INSTALLAZIONE - METODO 1 (Sostituzione Diretta)
================================================================================

1. Vai nella cartella di installazione del gioco
2. FAI UN BACKUP dei file originali prima!
3. Copia tutti i file dalla cartella "translated" nella cartella del gioco
4. Sovrascrivi quando richiesto
5. Avvia il gioco

Per ripristinare i file originali, copia dalla cartella "backup_original".

${hasXUnity ? `
================================================================================
INSTALLAZIONE - METODO 2 (XUnity.AutoTranslator - Consigliato per giochi Unity)
================================================================================

Questo metodo NON modifica i file originali del gioco.

1. Scarica e installa BepInEx:
   https://github.com/BepInEx/BepInEx/releases

2. Scarica e installa XUnity.AutoTranslator:
   https://github.com/bbepis/XUnity.AutoTranslator/releases

3. Copia i file .txt dalla cartella "XUnity_AutoTranslator" in:
   [Cartella Gioco]/BepInEx/Translation/${metadata.targetLanguage}/Text/

4. Avvia il gioco - le traduzioni saranno applicate automaticamente!

Vantaggi di questo metodo:
- I file originali rimangono intatti
- Facile aggiornare le traduzioni
- Può essere attivato/disattivato
- Funziona con gli aggiornamenti del gioco
` : ''}

================================================================================
FILE INCLUSI
================================================================================

${files.map(f => `- ${f.relativePath} (${f.stringCount} stringhe)`).join('\n')}

================================================================================
NOTE
================================================================================

${metadata.notes || 'Nessuna nota aggiuntiva.'}

Questa traduzione è stata creata usando GameStringer.

================================================================================
`.trim();
}

/**
 * Esporta in formato .gstranslation (formato proprietario)
 */
export async function exportGSTranslation(
  files: TranslatedFile[],
  metadata: PatchMetadata
): Promise<Blob> {
  const data = {
    version: '1.0',
    metadata,
    files: files.map(f => ({
      path: f.relativePath,
      originalPath: f.originalPath,
      format: f.format,
      stringCount: f.stringCount,
      content: f.content,
      originalContent: f.originalContent
    }))
  };
  
  const json = JSON.stringify(data);
  
  // Comprimi con gzip-like encoding
  const encoder = new TextEncoder();
  const encoded = encoder.encode(json);
  
  return new Blob([encoded], { type: 'application/x-gstranslation' });
}

/**
 * Importa da formato .gstranslation
 */
export async function importGSTranslation(
  blob: Blob
): Promise<{ files: TranslatedFile[]; metadata: PatchMetadata }> {
  const text = await blob.text();
  const data = JSON.parse(text);
  
  return {
    metadata: data.metadata,
    files: data.files.map((f: any) => ({
      originalPath: f.originalPath,
      relativePath: f.path,
      content: f.content,
      originalContent: f.originalContent,
      format: f.format,
      stringCount: f.stringCount
    }))
  };
}
